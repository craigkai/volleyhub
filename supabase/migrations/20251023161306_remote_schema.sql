create extension if not exists "http" with schema "extensions";


create type "public"."StageType" as enum ('ROUND_ROBIN', 'SINGLE_ELIMINATION', 'DOUBLE_ELIMINATION');

create type "public"."matchstate" as enum ('INCOMPLETE', 'COMPLETE');

create table "public"."events" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "owner" uuid not null,
    "courts" bigint default '2'::bigint,
    "pools" bigint,
    "date" timestamp without time zone,
    "scoring" text,
    "refs" text default 'provided'::text,
    "description" text,
    "current_round" integer default 0
);


alter table "public"."events" enable row level security;

create table "public"."matches" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "team1" bigint,
    "team2" bigint,
    "team1_score" bigint,
    "team2_score" bigint,
    "event_id" bigint not null,
    "court" bigint not null default '0'::bigint,
    "round" bigint not null default '0'::bigint,
    "ref" bigint,
    "type" text not null default 'pool'::text,
    "child_id" bigint,
    "state" matchstate not null default 'INCOMPLETE'::matchstate
);


alter table "public"."matches" enable row level security;

create table "public"."teams" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "name" text not null,
    "state" text default 'active'::text,
    "event_id" bigint
);


alter table "public"."teams" enable row level security;

create table "public"."users" (
    "id" uuid not null,
    "name" text,
    "is_admin" boolean not null default false,
    "approved" boolean not null default false,
    "approved_at" timestamp without time zone,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "rejected" boolean not null default false
);


alter table "public"."users" enable row level security;

CREATE UNIQUE INDEX events_pkey ON public.events USING btree (id);

CREATE UNIQUE INDEX game_pkey ON public.matches USING btree (id);

CREATE INDEX idx_matches_event_id ON public.matches USING btree (event_id);

CREATE INDEX idx_users_approved ON public.users USING btree (approved);

CREATE INDEX idx_users_id ON public.users USING btree (id);

CREATE INDEX idx_users_is_admin ON public.users USING btree (is_admin);

CREATE UNIQUE INDEX team_pkey ON public.teams USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

alter table "public"."events" add constraint "events_pkey" PRIMARY KEY using index "events_pkey";

alter table "public"."matches" add constraint "game_pkey" PRIMARY KEY using index "game_pkey";

alter table "public"."teams" add constraint "team_pkey" PRIMARY KEY using index "team_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."events" add constraint "events_owner_fkey" FOREIGN KEY (owner) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."events" validate constraint "events_owner_fkey";

alter table "public"."matches" add constraint "public_matches_child_id_fkey" FOREIGN KEY (child_id) REFERENCES matches(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."matches" validate constraint "public_matches_child_id_fkey";

alter table "public"."matches" add constraint "public_matches_event_id_fkey" FOREIGN KEY (event_id) REFERENCES events(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."matches" validate constraint "public_matches_event_id_fkey";

alter table "public"."matches" add constraint "public_matches_ref_fkey" FOREIGN KEY (ref) REFERENCES teams(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."matches" validate constraint "public_matches_ref_fkey";

alter table "public"."matches" add constraint "public_matches_team1_fkey" FOREIGN KEY (team1) REFERENCES teams(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."matches" validate constraint "public_matches_team1_fkey";

alter table "public"."matches" add constraint "public_matches_team2_fkey" FOREIGN KEY (team2) REFERENCES teams(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."matches" validate constraint "public_matches_team2_fkey";

alter table "public"."teams" add constraint "teams_event_id_fkey" FOREIGN KEY (event_id) REFERENCES events(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."teams" validate constraint "teams_event_id_fkey";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  insert into public.users (id, name, is_admin, approved)
  values (new.id, new.email, false, false);
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.notify_round_updates()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    team1_name TEXT;
    team2_name TEXT;
    ref_name TEXT;
    event_id TEXT;
BEGIN
    -- Only trigger on round updates (when round changes from null to a value)
    IF OLD.round IS NULL AND NEW.round IS NOT NULL THEN

        -- Get team names and event info
        SELECT t1.name, t2.name, tr.name, e.id::text
        INTO team1_name, team2_name, ref_name, event_id
        FROM teams t1, teams t2, teams tr, events e
        WHERE t1.id = NEW.team1
        AND t2.id = NEW.team2
        AND tr.id = NEW.referee_id
        AND e.id = NEW.event_id;

        -- Notify team1 players
        IF team1_name IS NOT NULL THEN
            PERFORM net.http_post(
                url := 'https://your-project-ref.supabase.co/functions/v1/send-push-notification',
                headers := jsonb_build_object(
                    'Content-Type', 'application/json',
                    'Authorization', 'Bearer ' || 'your-anon-key'
                ),
                body := jsonb_build_object(
                    'eventId', event_id,
                    'teamName', team1_name,
                    'round', NEW.round,
                    'action', 'round_assigned',
                    'isRef', false
                )
            );
        END IF;

        -- Notify team2 players
        IF team2_name IS NOT NULL THEN
            PERFORM net.http_post(
                url := 'https://your-project-ref.supabase.co/functions/v1/send-push-notification',
                headers := jsonb_build_object(
                    'Content-Type', 'application/json',
                    'Authorization', 'Bearer ' || 'your-anon-key'
                ),
                body := jsonb_build_object(
                    'eventId', event_id,
                    'teamName', team2_name,
                    'round', NEW.round,
                    'action', 'round_assigned',
                    'isRef', false
                )
            );
        END IF;

        -- Notify referee
        IF ref_name IS NOT NULL THEN
            PERFORM net.http_post(
                url := 'https://your-project-ref.supabase.co/functions/v1/send-push-notification',
                headers := jsonb_build_object(
                    'Content-Type', 'application/json',
                    'Authorization', 'Bearer ' || 'your-anon-key'
                ),
                body := jsonb_build_object(
                    'eventId', event_id,
                    'teamName', ref_name,
                    'round', NEW.round,
                    'action', 'ref_assigned',
                    'isRef', true
                )
            );
        END IF;

    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.send_round_notifications(p_event_id uuid, p_round integer)
 RETURNS TABLE(team_name text, notification_sent boolean)
 LANGUAGE plpgsql
AS $function$
DECLARE
    match_record RECORD;
    team1_name TEXT;
    team2_name TEXT;
    ref_name TEXT;
BEGIN
    -- Get all matches for this round
    FOR match_record IN
        SELECT m.*, t1.name as t1_name, t2.name as t2_name, tr.name as ref_name
        FROM matches m
        LEFT JOIN teams t1 ON t1.id = m.team1
        LEFT JOIN teams t2 ON t2.id = m.team2
        LEFT JOIN teams tr ON tr.id = m.referee_id
        WHERE m.event_id = p_event_id AND m.round = p_round
    LOOP
        -- Return results for team1
        IF match_record.t1_name IS NOT NULL THEN
            team_name := match_record.t1_name;
            notification_sent := true;
            RETURN NEXT;
        END IF;

        -- Return results for team2
        IF match_record.t2_name IS NOT NULL THEN
            team_name := match_record.t2_name;
            notification_sent := true;
            RETURN NEXT;
        END IF;

        -- Return results for referee
        IF match_record.ref_name IS NOT NULL THEN
            team_name := match_record.ref_name;
            notification_sent := true;
            RETURN NEXT;
        END IF;
    END LOOP;

    RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_match_state()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
    -- Check if the state is different
    IF (SELECT state FROM matches WHERE id = NEW.id) IS DISTINCT FROM
       (SELECT CASE
                  WHEN (NEW.team1_score IS NOT NULL AND NEW.team2_score IS NOT NULL) THEN 'COMPLETE'::matchstate
                  ELSE 'INCOMPLETE'::matchstate
              END)
    THEN
        -- Update the state
        UPDATE matches
        SET state = CASE 
                        WHEN NEW.state = 'COMPLETE'::matchstate THEN 'INCOMPLETE'::matchstate 
                        ELSE 'COMPLETE'::matchstate 
                    END
        WHERE id = NEW.id;
    END IF;
    RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

-- Helper functions for RLS policies
CREATE OR REPLACE FUNCTION current_user_is_admin()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.users
    WHERE id = auth.uid()
    AND is_admin = true
  );
END;
$$;

CREATE OR REPLACE FUNCTION current_user_is_approved()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.users
    WHERE id = auth.uid()
    AND approved = true
  );
END;
$$;

create policy "Enable delete for users based on user_id"
on "public"."events"
as permissive
for delete
to authenticated
using (((auth.uid() = owner) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable insert for authenticated users only"
on "public"."events"
as permissive
for insert
to authenticated
with check (((EXISTS ( SELECT 1
   FROM users u
  WHERE ((u.id = auth.uid()) AND (u.approved = true)))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable read access for all users"
on "public"."events"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on event owner id"
on "public"."events"
as permissive
for all
to authenticated
using (((auth.uid() = owner) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))))
with check (((auth.uid() = owner) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable delete for matches where auth'd user is owner of event"
on "public"."matches"
as permissive
for delete
to authenticated
using (((auth.uid() IN ( SELECT events.owner
   FROM events
  WHERE (events.id = matches.event_id))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable insert for authenticated users only"
on "public"."matches"
as permissive
for insert
to authenticated
with check (((EXISTS ( SELECT 1
   FROM users u
  WHERE ((u.id = auth.uid()) AND (u.approved = true)))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable read access for all users"
on "public"."matches"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on email"
on "public"."matches"
as permissive
for update
to authenticated
using (((auth.uid() IN ( SELECT events.owner
   FROM events
  WHERE (events.id = matches.event_id))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))))
with check (((auth.uid() IN ( SELECT events.owner
   FROM events
  WHERE (events.id = matches.event_id))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable delete for users based on event owner"
on "public"."teams"
as permissive
for delete
to authenticated
using (((auth.uid() IN ( SELECT events.owner
   FROM events
  WHERE (events.id = teams.event_id))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable insert for authenticated users only where event owner"
on "public"."teams"
as permissive
for insert
to authenticated
with check (((auth.uid() IN ( SELECT events.owner
   FROM events
  WHERE (events.id = teams.event_id))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Enable read access for all users for active teams"
on "public"."teams"
as permissive
for select
to public
using ((state = 'active'::text));


create policy "Enable update for users based on email"
on "public"."teams"
as permissive
for update
to authenticated
using (((auth.uid() IN ( SELECT events.owner
   FROM events
  WHERE (events.id = teams.event_id))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))))
with check (((auth.uid() IN ( SELECT events.owner
   FROM events
  WHERE (events.id = teams.event_id))) OR (auth.uid() IN ( SELECT users.id
   FROM users
  WHERE (users.is_admin = true)))));


create policy "Admin can read all"
on "public"."users"
as permissive
for select
to authenticated
using (((auth.uid() = id) OR (is_admin = true)));


create policy "Admin can update non-admin users"
on "public"."users"
as permissive
for update
to authenticated
using (((current_user_is_admin() = true) AND (is_admin = false)))
with check ((is_admin = false));


create policy "Allow insert for trigger"
on "public"."users"
as permissive
for insert
to public
with check (true);


create policy "User can read own data"
on "public"."users"
as permissive
for select
to authenticated
using ((id = auth.uid()));


create policy "Users delete self or admin"
on "public"."users"
as permissive
for delete
to authenticated
using (((auth.uid() = id) OR current_user_is_admin()));


create policy "Users insert"
on "public"."users"
as permissive
for insert
to authenticated
with check ((current_user_is_approved() OR current_user_is_admin()));


create policy "Users update self or admin"
on "public"."users"
as permissive
for update
to authenticated
using (((auth.uid() = id) OR current_user_is_admin()))
with check (((auth.uid() = id) OR current_user_is_admin()));


CREATE TRIGGER on_match_update_set_state AFTER UPDATE ON public.matches FOR EACH ROW EXECUTE FUNCTION update_match_state();

CREATE TRIGGER trigger_notify_round_updates AFTER UPDATE ON public.matches FOR EACH ROW EXECUTE FUNCTION notify_round_updates();


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();


